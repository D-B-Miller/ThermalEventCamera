import threading
import os
import pigpio
import sys
from datetime import time as timestruct
from datetime import datetime
import dataclasses
import struct
import subprocess

# structure for the event data
# holds the sign of the change and the time of update
@dataclasses.dataclass
class EventData:
    """
        dataclass for holding the event data generated by an ThermalRaw
        device
    """
    sign : int
    ut : datetime.time

    def __init__(self,sign:int = 0):
        """
            Constructor for EventData. Accepts a sign value and sets the update
            time ut using datetime.datetime.now().time()

            sign (int) : Sign of the data change. Should be -1,0 or 1 to represent
                        negative, no or positive change in data repsectively.
        """
        self.sign = sign
        self.ut = datetime.now().time()

class ThermalPig:
	def __init__(self,**kwargs):
		if 'start_daemon' in kwargs:
			# if start_daemon flag is set
			if kwargs['start_daemon']:
				# check to see if a daemon has been started
				# if so kill it
				if ThermalPig.check_daemon():
					out = subprocess.run(['sudo','killall','pigpiod'],capture_output=True)
					print(f"daemon kill -> {out.stdout},{out.stderr}")
				# start new daemon
				out = subprocess.run(['sudo','pigpiod'],capture_output=True)
				print(f"daemon start -> {out.stdout}, {out.stderr}")
		# get local pi
		self.pi  = pigpio.pi()
		# if connected
		if not self.pi.connected:
			print("failed to get pi after creating daemon. check host name")
			return
		else:
			# open i2c-1 at address 0x33
			self.__h = self.pi.i2c_open(1,0x33)
			print(f"i2c handle : {self.__h}")
			self.__last = None
			# perform a test read
			try:
				self.__last = self.pi.i2c_read_device(self.__h,1664)[1]
			except BaseException:
				print("Unexpected error during test read ",sys.exc_info()[0])
		# setup thread
		self.__thread = threading.Thread(target=ThermalPig.update_wrapper,args=(self,),daemon=True)
		# data matrices
		self.out = [EventData()]*832
		# stop flag
		self.__stop = False
	def __del__(self):
		# kill pig daemon
		subprocess.run(['sudo','killall','pigpiod'])
		# stop thread
		if self.__thread.is_alive():
			self.stop()
	# start update thread
	def start(self):
		self.__stop = False
		self.__thread.start()
	# stop thread with 5 sec timeout on join command
	def stop(self):
		self.__stop = True
		self.__thread.join(5.0)
	# thread wrapper for update function
	def update_wrapper(self):
		if not self.pi.connected:
			print("Not connected to Pi. Exiting thread early")
			return
		while not self.__stop:
			update()
	# update difference array
	def update(self):
		data = self.pi.i2c_read_device(self.__h,1664)[1]
		data = [bb for bb in data]
		if self.__last is not None:
			return [d-l for d,l in zip(data,self.__last)]
		self.__last = list(data)
	# with enter behaviour
	def __enter__(self):
		return self
	# with exit behaviour
	def __exit__(self):
		# close device connection
		self.pi.close()
		# kill pig daemons
		subprocess.run(['sudo','killall','pigpiod'])
	def check_daemon():
		# call to get ids of pig daemons
		tt = subprocess.run(['sudo','pigs','t'],capture_output=True)
		# if running, it returns a number followed by a newline
		# remove new line
		tt = tt.strip('\n')
		# attempt to convert number to an integer
		# if it fails then there are no daemons
		try:
			int(tt.stdout)
			return 1
		except ValueError:
			return 0
